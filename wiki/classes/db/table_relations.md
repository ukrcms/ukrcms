# Опис зв'язків між моделями

## Типи звязків
Існує 3 типи звязків.
- RELATIONS_ONE_TO_ONE - вказує, що модель має зв'язок з однією моделлю
- RELATIONS_ONE_TO_MANY - вказує, що модель має зв'язок з багатьма моделями
- RELATIONS_MANY_TO_MANY - вказує, що модель має зв'язок з багатьма моделями через зв'язкову таблицю

Розглянемо ці приклади детальніше:

### Один до одного - RELATIONS_HAS_ONE
Для прикладу у нас є таблиця користувачів і таблиця паспортів.
Кожен користувач має один паспорт. Відповідно паспорт
належить тільки одному користувачу.

Опишемо зв'язок у таблиці Користувачі. Пам'ятаємо що користувач має один паспорт.

```php
namespace \App\Office\Users;
class Table extends \Uc\Db\Table {

  public function relations(){
    return array(
     'passport'=>array(
       'type'=>static::RELATIONS_HAS_ONE,
       'table'=>\App\Passport\Table::N,
       'foreignField'=>'passport_id',
     )
    );
  }

}
```
Отже ключ масиву - passport.
Ця назва буде використовуватись для отримання паспорту користувача.
```
# Вибираємо користувача під номером 1
$user = \App\Users\Table::instance()->fetchOne(1);

# Виводимо дату реєстрації паспорту який належить користувачу 1
echo $user->passport->registrationDate;
```
- type  - тип зв'язку (існує 3 типи зв'язків, вказані вище).
- table - назва таблиці, в якій знаходяться зв'язані об'єкти.
- foreignField - поле у таблиці users. У це поле записується номер паспорта.

Наступний крок це задати зв'язки для таблиці паспорт.
Ми знаємо що у користувача є 1н паспорт. Отже у кожного паспорта є користувач.
Враховуючи цей факт що ми уже зберігаємо номер паспорта  у таблиці Користувачі,
даний звязок буде трохи відрізнятись від попереднього.

```php
namespace App\Office\Passports;

class Table extends \Uc\Db\Table {
  public function relations(){
    return array(
      'User' => array(
        'type' => static::RELATIONS_HAS_ONE,
        'table' => \App\User\Table::N,
        'myField' => 'passport_id',
      )
    );
  }
}
```
Головна відмінність це поле myField. Цей ключ вказує що поле passport_id знаходиться
в таблиці Users.

Отже якщо поле знаходиться у таблиці до якої ми описуємо звязок, тоді пишемо myField у іншому випадку foreignField.

### Один до багатьох - RELATIONS_ONE_TO_MANY
Цей звязок використовується тоді, коли у об'єкта є багато зв'язаних об'єктів. Це може бути Стаття в якої багато коментарів.
Або наприклад у користувача є декілька авто.

```php
namespace \App\Office\Users;

class Table extends \TestApp\Table {
  public function relations() {
    return array(
      'cars' => array(
        'type' => static::RELATION_ONE_TO_MANY,
        'table' => \TestApp\Office\Cars\Table::N,
        'myField' => 'user_id'
      )
    );
  }
}

```
Ключ myField вказує що id користувача зберігається у полі user_id в таблиці Cars.
Як описати зворотній зв'язок: у авто є один користувач, можня глянути вище ;)


### Багато до багатьох - RELATIONS_MANY_TO_MANY
Цей тип звязку є найскладнішим. У проектах зустрічається не дуже часто, але
коли потрібен тоді реалізація його вимагає високої уваги від програміста.
Ми вирішили спростити функціонал і реалізувати цей тип звязку за вас.
Все що вам потрібно це створити додаткову таблицю (3 поля) і описати зв'язки у двох класах.

Для прикладу розглянемо реалізацію майнових відношень.
У нас є користувачі (Users). Також у нас є будівлі (Houses).
Кожен користувач може мати у власності деяку частину будівлі, відповідно у одній будівлі може
бути декілька власників.

Дане співвідношення називається багато до багатьох.
Іншими словами всю суть зв'язка можна передати в наступному реченні:
один користувач має багато будівель, у одноєї будівлі є багато співвласників.

Дані сутності пов'язані між собою через додаткову таблицю.
Структура нашої бази:
- uc_users - таблиця користувачів
- uc_houses - таблиця будівель
- uc_office_users_houses - таблиця зв'язків, яка містить номер користувача і номер будівлі.

Отже задамо зв'язок для користувачів

```php
namespace App\Office\Users;

class Table extends \TestApp\Table {

  public function relations() {
    return array(
      'houses' => array(
        'type' => static::RELATION_MANY_TO_MANY,
        'table' => \App\Office\Houses\Table::N,
        'reference' => array(
          'tableName' => \Uc::app()->db->tablePrefix . 'office_users_houses',
          'myField' => 'user_id',
          'foreignField' => 'house_id',
        )
      ),
    );
  }
}
```

Масив з ключом `reference` описує зв'язкову таблицю.
- tableName - назва зв'язкової таблиці
- myField - вказує, що ключ з таблиці Users (так як ми описуємо зв'язок у цій таблиці) записується у поле user_id
- foreignField - вказує, що ключ з таблиці Houses записується у поле house_id

Дуже просто тримати список будівель, якими володіє користувач під номером 1:

```php
# Вибираємо користувача під номером 1
$user = \App\Office\Users\Table::instance()->fetchOne(1);

# виводимо номери будівель
foreach($user->houses as $house){
  echo $house->id . "<br>";
}

echo "Кількість будинків якими володіє користувач: ".count($user->houses)."<br>";
```

Тепер, задамо зворотній зв'язок для будівель.

```php
namespace App\Office\Houses;
class Table extends \TestApp\Table {

  public function relations() {
    return array(
      'users' => array(
        'type' => static::RELATION_MANY_TO_MANY,
        'table' => \App\Office\Users\Table::N,
        'reference' => array(
          'tableName' => \Uc::app()->db->tablePrefix . 'office_users_houses',
          'myField' => 'house_id',
          'foreignField' => 'user_id',
        )
      ),
    );
  }

}
```


## У чому відмінність зв'язків один до багатьох і багато до багатьох?

Різниця двох зв'язків один до багатьох і багато до багатьох полягає в тому що при використанні
звязку один до багатьох у нас виконується умова:
У об'єкта А є багато об'єктів Б. У об'єкта Б є один об'єкт А.
(у одного користувача є декілька автомобілів, у одного автомобіля є один користувач)

Для зв'язку багато до багатьох виконується умова:
У об'єкта А є багато об'єктів Б. У об'єкта Б є багато об'єктів А.
(один користувач є власником декількох будинків, один будинок має декількох власників)



## Користь звязків
Зв'язки дуже потужна і корисна річ при розробці веб сайту.
В першу чергу вони допомагають реалізувати принцип DRY і звісно підвищити читабельність коду.
Вам не потрібно кожен раз писати функцію отримання зв'язкового обєкту.

Зв'язки використовуються не тілкьи при вибірці зв'язкового об'єкту, а і при фільтруванні даних.
Читайте детальніше у документації класу [Працюємо з вибіркою даних із бази - клас select](select.md)
