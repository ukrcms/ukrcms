# Опис звязків між моделями

## Типи звязків
Існує 3 типи звязків.
- RELATIONS_ONE_TO_ONE - вказує що модель має звязок з однією моделлю
- RELATIONS_ONE_TO_MANY - вказує що модель має звязок з багатьма моделями
- RELATIONS_MANY_TO_MANY - вказує що модель має звязок з багатьма моделями через звязкову таблицю

Розглянемо ці приклади детальніше:

### Один до одного - RELATIONS_HAS_ONE
Для прикладу у нас є таблиця користувачів і таблиця паспортів.
Кожен користувач має один паспорт. Відповідно паспорт
належить тільки одному користувачу.

Опишемо звякзок у таблиці Користувачі. Памятаємо що користувач має один паспорт.

```php
namespace \App\Office\Users;
class Table extends \Uc\Db\Table {

  public function relations(){
    return array(
     'passport'=>array(
       'type'=>static::RELATIONS_HAS_ONE,
       'table'=>\App\Passport\Table::N,
       'foreignField'=>'passport_id',
     )
    );
  }

}
```
Отже ключ масиву - passport.
Ця назва буде використовуватись для отримання паспорту користувача.
```
# Вибираємо користувача під номером 1
$user = \App\Users\Table::instance()->fetchOne(1);

# Виводимо дату реєстрації паспорту який належить користувачу 1
echo $user->passport->registrationDate;
```
- type  - тип звязку (існує 3 типи звязків, вказані вище).
- table - назва таблиці в якій знаходяться звязані обєкти.
- foreignField - поле у таблиці users. У це поле записується номер паспорта.

Наступний крок це задати звязки для таблиці паспорт.
Ми знаємо що у користувача є 1н паспорт. Отже у кожного паспорта є користувач.
Враховуючи цей факт що ми уже зберігаємо номер паспорта  у таблиці Користувачі,
даний звязок буде трохи відрізнятись від попереднього.

```php
namespace App\Office\Passports;

class Table extends \Uc\Db\Table {
  public function relations(){
    return array(
      'User' => array(
        'type' => static::RELATIONS_HAS_ONE,
        'table' => \App\User\Table::N,
        'myField' => 'passport_id',
      )
    );
  }
}
```
Головна відмінність це поле myField. Цей ключ вказує що поле passport_id знаходиться
в таблиці Users.

Отже якщо поле знаходиться у таблиці до якої ми описуємо звязок, тоді пи пишемо myField у іншому випадку foreignField.

### Один до багатьох - RELATIONS_ONE_TO_MANY
Цей звязок використовується тоді, коли у обєкта є багато звязаних обєктів. Це може бути Стаття в якої багато коментарів.
Або наприклад у користувача є декілька авто.

```
namespace \App\Office\Users;

class Table extends \TestApp\Table {
  public function relations() {
    return array(
      'cars' => array(
        'type' => static::RELATION_ONE_TO_MANY,
        'table' => \TestApp\Office\Cars\Table::N,
        'myField' => 'user_id'
      )
    );
  }
}

```
Ключ myField вказує що id користувача зберігається у полі user_id в таблиці cars.
Як описати зворотній звязок: у авто є один користувач, можня глянути вище ;)


### Багато до багатьох - RELATIONS_MANY_TO_MANY
Цей тип звязку є наскладнішим. У проектах зустрічаєється не дуже часто, але
коли потрібен тоді реалізація його вимагає високої уваги від програміста.
Ми вирішили спростити функціонал і реалізувати цей тип звязку за вас.
Все що вам потрібно це створити додаткову таблицю (3 поля) і описати звязки у двох класах.

Для прикладу розглянемо реалізацію майнових відношень.
У нас є користувачі (Users). Також у нас є будівлі (Houses).
Кожен користувач може мати у власності деяку частину будівлі, відповідно у одній будівлі може
бути декілька власників.

Дане співвідношення називається багато до багатьох.
Іншими словами всю суть звязка можа передати в наступному реченні:
один користувач має багато будівель, у одноєї будівлі є багато співвласників.

Дані сутності повязані між собою через додаткову табилцю.
Структура нашої бази:
- uc_users - таблиця користувачів
- uc_houses - таблиця будівель
- uc_users_houses - таблиця звякзів, яка містить номер користувачі і номер будівлі.

Отже задамо звязок для користувачів

```php
namespace App\Office\Users;

class Table extends \TestApp\Table {

  public function relations() {
    return array(
      'houses' => array(
        'type' => static::RELATION_MANY_TO_MANY,
        'table' => \App\Office\Houses\Table::N,
        'reference' => array(
          'tableName' => \Uc::app()->db->tablePrefix . 'office_users_houses',
          'myField' => 'user_id',
          'foreignField' => 'house_id',
        )
      ),
    );
  }
}
```

Масив з ключом `reference` описує звязкову таблицю.
- tableName - назва звязкової таблиці
- myField - вказує що ключ з таблиці Users (так як ми описуємо звязок у цій таблиці) записується у поле user_id
- foreignField - вказує що ключ з таблиці Houses записується у поле house_id

Дуже просто тримати список будівель якими володіє користувач під номером 1:

```php
# Вибираємо користувача під номером 1
$user = \App\Office\Users\Table::instance()->fetchOne(1);

# виводимо номери будівель
foreach($user->houses as $house){
  echo $house->id . "<br>";
}

echo "Кількість будинків якими володіє користувач: ".count($user->houses)."<br>";
```
Тепер задамо звязок зворотній звязок для будівель.

```php
namespace App\Office\Houses;
class Table extends \TestApp\Table {

  public function relations() {
    return array(
      'users' => array(
        'type' => static::RELATION_MANY_TO_MANY,
        'table' => \App\Office\Users\Table::N,
        'reference' => array(
          'tableName' => \Uc::app()->db->tablePrefix . 'office_users_houses',
          'myField' => 'house_id',
          'foreignField' => 'user_id',
        )
      ),
    );
  }

}
```


## У чому відмінність звязків один до багатьох і багато до багатьох?

Різниця двох звязків один до багатьох і багато до багатьох полягає в тому що при використанні
звязку один до багатьох у нас виконується умова:
У обєкта А є багато обєктів Б. У обєкта Б є один обєкт А.
(у одного користувача є декілька автомобілів, у одного автомобіля є один користувач)

Для звязку багато до багатьох виконується умова:
У обєкта А є багато обєктів Б. У обєкта Б є багато обєктів А.
(один користувач є власником декількох будинків, один будинок має декількох власників)



## Користь звязків
Звязки дуже потужна і корисна річ при розробці веб сайту.
В першу чергу вони допомагають реалізувати принцип DRY і звісно підвищити читабельність коду.
Вам не потрібно кожен раз писати функцію отримання звязкового обєкту.

Звязки використовуються не тілкьи при вибірці звязкового обєку, а і при фільтруванні даних.
Читайте детальніше у документації класу [Працюємо з вибіркою даних із бази - клас select](select.md)